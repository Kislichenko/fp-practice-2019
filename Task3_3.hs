module Task3_3 where

{-
  Задание 3.3
  Множество на основе предикатов
-}
import Data.Functor.Contravariant

newtype PSet a = PSet{ contains :: (a -> Bool) }

-- Реализуйте классы Monoid и Functor
-- Объясните в комментариях, почему они реализованы именно так

-- в качестве операции добавления моноида к моноиду будем использовать логическое ИЛИ
-- но можно было бы использовать и логическое И
instance Semigroup (PSet a) where
    (<>) (PSet x1) (PSet x2) = PSet (\x -> x1 x || x2 x)

-- memty - нейтральное значение, называемое нулём моноида
-- Экземпляры Monoid подчиняются дополнительному правилу(<>) == mappend
-- Это сделано для того, чтобы экземпляр Monoid был эквивалентен более строгому Semigroup
instance Monoid (PSet a) where
    mempty = PSet (\arg -> False)

-- С помощью функтора мы можем применять функцию к упакованному значению, используя 
-- fmap :: (a -> b) -> f a -> f b. Контравариантные функторы - функторы с переворотом
-- аргументов. Тип основного метода контравариантного функтора 
-- contramap :: Contravariant f => (a -> b) -> f b -> f a. По факту PSet - это обертка 
-- над предикативной функцией. Реализовать ковариантный функтор не получится, т.к.
-- при передаче фукции контейнеру, последний подгражет функцию внутрь себя и без 
-- извлечений элемента применяет переданную функцию к элементу. А контравариантный
-- функтор предоставляет возможность извлечь элемент, построить обратную функцию и
-- применить ее к содержимому контейнера.
instance Contravariant PSet where
  contramap f p = PSet (contains p . f)
