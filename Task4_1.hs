module Task4_1 where

{-
  Задание 4.1
  Реализация монады над функцией.
  Реализуйте все требуемые классы типов и объясните, почему они реализованы именно так.
-}

-- Монада над функцией. В качестве входного значения `fun` может быть что угодно
-- Собственно, почему бы не `String`?
data FunMonad a = FunMonad { fun :: String -> a }

-- реализуйте классы `Functor`, `Applicative` и `Monad` для типа `FunMonad`

-- Аппликативный функтор нужен для применения упакованной функции
-- к упакованному значению, используя <*>.
-- Для большего понимания проанализируем тип аппликативного функтора,
-- тип последовательного применения <*>: f (a -> b) -> f a -> f b. 
-- Теперь подставим (->)r, где (->) - стрелка функции, а r - первый тип (в нашем случае
-- FunMonad) из двух типов, необходимых для получения типа функции между этими двумя типами. 
-- Получаем: r -> (a -> b) -> (r -> a) -> (r -> b). Для <*> мы
-- должны вернуть функцию типа (r -> b). Первый аргумент fun1 есть функция
-- с типом fun1 :: r -> a -> b. Второй аргумент есть функция с типом fun2 :: r -> a. 
-- Из типов этих двух аргументов (функций) видно, что мы должны в качестве
-- первых аргументов передаваемых функций использовать значение типа r.
-- Этого можно добиться, если использовать лямбда-выражение с принимаемым входным
-- значением типа x :: r (возвращаемая функция типа r -> b). Если подставить
-- параметр x в передаваемые функции, то мы сможем получить функцию (a -> b)и
-- значение a. Чтобы получить значение a нужно сделать ((fun fun2) x), чтобы получить
-- (a -> b) нужно сделать ((fun fun1) x). Теперь нужно подставить ((fun fun2) x) в
-- ((fun fun1) x) качестве аргумента, и мы получим b.
-- Тип pure :: a -> fa. Подставим (->) r и получим: pure :: a -> (r -> a). 
-- Воспользуемся также лямбда-выражением, но, т.к. принмаемый аргумент в pure
-- есть конечный, который просто нужно обернуть в тип FunMonad, в соответствии с
-- соглашением, когда параметр в лямбда выражении не нужен, воспользуемся 
-- \_ в качестве входа и сделаем следующее лямбда-выражение: \_ -> x.
instance Applicative FunMonad where
  pure x = FunMonad (\_ -> x)
  fun1 <*> fun2 = FunMonad (\x -> ((fun fun1) x) $ ((fun fun2) x))

-- Functor нужен для того, чтобы применять функцию к упакованному значению,
-- используя fmap.
-- Приведу краткие раасуждение подобные для аппликативного функтора.
-- Тип fmap: (a -> b) -> f a -> f b. Подставим (->)r и получим:
-- (a -> b) -> (r -> a) -> (r -> b). Для получения a: ((fun fun1) x), где x - 
-- вход в лямбда-выражение c типом r. Для получения b подставим ((fun fun1) x)
-- в качестве аргумента в f.
instance Functor FunMonad where
  fmap f fun1 = FunMonad (\x -> f ((fun fun1) x))

-- Монада нужна для того, чтобы применять функцию, возвращающую  упакованное значение,
-- к упакованному значению, используя >>=.
-- Тип (>>=): m a -> (a -> m b) -> m b. Подставим (->)r и получим:
-- (r -> a) -> (a -> (r -> b)) -> (r -> b). Рассуждения аналогичны выше
-- представленным. 
-- return == pure, поэтому явно не пишу.
instance Monad FunMonad where
  fun1 >>= f = FunMonad (\x ->  fun (f $ (fun fun1) x) x)

